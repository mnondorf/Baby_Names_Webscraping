import pandas as pd
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options

# Initalize list that will hold the user input of year(s) to search
years_to_query = []

def initialize_driver():
    '''
    This function initializes the webdriver. Doing so in a function allows the same instance of the webdriver to be
    used in multiple functions without starting a new page.
    '''
    # Set up Chrome options for headless mode
    chrome_options = Options()
    chrome_options.add_argument('--headless')  
    chrome_options.add_argument('--disable-gpu')  # Disable GPU acceleration (needed in headless mode)
    chromedriver_path = r"C:\Users\menon\Documents\Programming\Baby_Names_Project\chromedriver-win64\chromedriver-win64\chromedriver"
    
    return webdriver.Chrome(executable_path=chromedriver_path, options=chrome_options)

def ask_user():
    '''
    This function asks the user which year(s) they would like to search and creates a list from the response.
    '''
    # Ask user for year(s) to query website for
    x = input("What year or years would you like to search?\nIf entering a range, please use this format: 1900-1910.\nIf entering a list, use commas between years. ex: 1900, 1950, 2000.\n")
    
    # Process the response and populate the list "years_to_query" in preparation for website submission
    if x.find("-") != -1:
        # Slice and make list from range
        loc = x.find("-")
        range_start = x[:loc]
        range_end = x[loc+1:]
        for year in range(int(range_start),int(range_end)+1):
            years_to_query.append(year) 
       
    elif x.find(",") != -1:
        # Create list from string and send to other functions
        commas = x.count(",")
        # Search for white spaces and remove them before assigning indices for commas
        if x.find(" ")!= -1:
            x = x.replace(" ","")
        # locate first comma and use for loop to create list of years
        loc = x.find(",")
        for instance in range(0,commas+1):
            year = x[loc-4:loc]
            years_to_query.append(year)
            loc +=5
    else:
        # If only a single year, append directly
        years_to_query.append(x)

def get_names(years_list, driver):
    '''
    This function takes the output from ask_user() and loops through the list. For each year in the list, it:
     - finds the appropriate search box on the webpage
     - clears it
     - inputs a year into the search box
     - clicks submit
     - creates a table of the 20 most popular names for that year that were scraped from the website
     - increments the counter by one to search the next year (if applicable) and repeats, appending each new scrape
       to the previous.
     - returns a 2D list of names
    '''
    # loop through all subsequent years and collate results
    list_of_names = []
    for year in years_list:
        time.sleep(1)        
        # Find the text box
        input_year = driver.find_element(By.ID,'yob') # locates input box
        input_year.clear()                             # clears box
        # Enter the year in question
        input_year.send_keys(str(year))           # fills in box with new date
        time.sleep(1)                                  # adds in delay of one second
        # Clicks button to submit request
        input_year.submit()                           
    
        # Scrape results
        top_names = driver.find_elements(By.XPATH,"//html/body/table[2]/tbody/tr/td[2]/p/table") # Table path that includes each year's table title for clarity

        for name in top_names:
            list_of_names.append(name.text)

    # Close the webdriver outside the loop
    driver.quit()
                     
    return list_of_names

def clean_zip_split(list1, list2): # list1 = names, list2 = years_to_query
    '''
    This function takes the list of names generated by the "get_names()" function and cleans it by:
    - creating a 2D table
    - splitting the strings in each list on the newline character
    - removing unnecessary rows
    - creating a separate list of the first row in each sub-list, which will become DF column headers, and then removing 
      that row
    - splitting the list again, this time on the first space and dropping everything to the left of that space
    
    It then "zips" them together into a single dictionary, with each set of results associated with the relevant year.
    
    Next, it splits the male and female names while maintaining the correct year association.
    '''
    table = []
    names = []
    cleaned_list = []
    popularity = []
    combined_dict ={}
    new_dict = {}
    
    # First step - Create 2d table (list of lists)    
    for year in list1:
        table.append([year])
        
    # Second step - Split list and list of lists within each year    
    for result in table:
        for year in result:
            each_name = year.split("\n")
            names.append(each_name)
            
    # Third step - drop the two unwanted rows
    for i in names:
        i.pop(1)
        i.pop(-1)
            
    # Fourth step - split results in list based on first white space and only keep part after the split    
    for year in names:
        popularity.append(year[0])
        del year[0]
        result = [item.split(' ', 1)[1] for item in year]
        cleaned_list.append(result)      
    
    # Fifth step - "zip" the years list and names list together and create a dictionary of the result          
    for year, value, in zip(list2,cleaned_list):
        if year in combined_dict:
            combined_dict[year].append(value)
        else:
            combined_dict[year] = value

    # Sixth step - loop through the dictionary and separate the female names from the male names. Reassociate 
    # years to each set of name results to create two sex-specific dictionaries of names by year searched.
    
    for year, names_list in combined_dict.items():
        first_half_names = [name.split()[0] for name in names_list]
        second_half_names = [name.split()[1] for name in names_list]
        new_dict[year] = second_half_names
        combined_dict[year] = first_half_names

    print(f"First Cleaning - Name Pairs Separated by Rank into Individual Strings, Extraneous Text Removed:\n{names}\n")
    print(f"Second Cleaning - Rank and Whitespace Removed:\n{cleaned_list}\n")
    print(f"Dictionary with Top 20 Male Names for Each Year Searched:\n{combined_dict}\n")
    print(f"Dictionary with Top 20 Female Names for Each Year Searched:\n{new_dict}\n")
    
    return count_names(combined_dict), count_names(new_dict)

def count_names(dictionary):
    '''
    This function takes a (sex-specific) dictionary, converts it into a DataFrame, and creates a list of unique names. 
    It then iterates through the DataFrame to count the number of occurrences of each name in the set of results. 
    '''
    unique_names = []
    name_counts = {}
    
    # Convert dictionary to DataFrame
    df = pd.DataFrame(dictionary)

    # Step 2 = iterate through the DataFrame and check if each value is already in the list of names. If not, 
    #append it to the list. 
    for index, row in df.iterrows():
        for col in df.columns:
            name = row[col]
            if name not in unique_names:
                unique_names.append(name)

    # Step 3 - loop through the names in the DataFrame and count occurrences
    for name in unique_names:
        count = (df == name).values.sum()
        name_counts[name] = count
    sorted_dict = dict(sorted(name_counts.items(),key=lambda item: item[1], reverse=True))

    return sorted_dict
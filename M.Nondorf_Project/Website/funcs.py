import pandas as pd
import time
#Set up Web Driver
from selenium import webdriver
from selenium.webdriver.common.by import By

def initialize_driver():
    return webdriver.Chrome(r"C:\Users\menon\Documents\Programming\Baby_Names_Project\chromedriver-win64\chromedriver-win64\chromedriver")

# Step 1 - radio buttons and user input
def get_yr_range(x):
    years_to_query = []
    # Slice and make list from range
    loc = x.find("-")
    range_start = x[:loc]
    range_end = x[loc+1:]
    for year in range(int(range_start),int(range_end)+1):
        years_to_query.append(year)
    return years_to_query
       
def get_yr_list(x):
    years_to_query = []
    commas = x.count(",")
    # Search for white spaces and remove them before assigning indices for commas
    if x.find(" ")!= -1:
        x = x.replace(" ","")
    # locate first comma and use for loop to create list of years
    loc = x.find(",")
    for instance in range(0,commas+1):
        year = x[loc-4:loc]
        years_to_query.append(year)
        loc +=5
    
    return years_to_query
    
def get_yr(x):
    years_to_query = []
    years_to_query.append(x)
    return years_to_query

# Step 2: Visit website and perform initial search
def call_and_click(yrs):
    # start webdriver
    driver = initialize_driver()  # Call the initialize_driver function   
    try:
        # go to url
        driver.get('https://www.ssa.gov/OACT/babynames/')
        # find the appropriate text box and clear it
        input_year = driver.find_element(By.XPATH,'//*[@id="year"]')
        input_year.clear()      
        
        # Load first year into input box
            # Check if the list is not empty before accessing its first element
        if yrs:
            input_year.send_keys(str(yrs[0]))
        time.sleep(1)                                               
        # Perform initial search of first year in requested range in order to get to the correct page.
        input_year.submit()

        list_of_names = get_names(driver, yrs)
       
        return list_of_names
    finally:
        # Quit the driver to close the window
        driver.quit()

def clean_zip_split(list1, list2): # list1 = names, list2 = years_to_query
    '''
    This function takes the list of baby names generated by the "get_list()" function and cleans it in preparation for 
    further modification.
    - creates a 2D table
    - splits the strings in each list on the newline character
    - removes unnecessary rows
    - creates a separate list of the first row in each sub-list, which will become DF column headers, and then removes 
      that row
    - splits lists again, this time on the first space and drops everything to the left of that space
    
    It then "zips" them together into a single dictionary, with each set of results associated with the relevant year.
    '''
    table = []
    names = []
    cleaned_list = []
    popularity = []
    combined_dict ={}
    new_dict = {}
    
    # First step - Create 2d table (list of lists)    
    for year in list1:
        table.append([year])
        
    # Second step - Split list and list of lists within each year    
    for result in table:
        for year in result:
            each_name = year.split("\n")
            names.append(each_name)
            
    # Third step - drop the two unwanted rows
    for i in names:
        i.pop(1)
        i.pop(-1)
            
    # Fourth step - to split results in list based on first white space and only keep part after the split    
    for year in names:
        popularity.append(year[0])
        del year[0]
        result = [item.split(' ', 1)[1] for item in year]
        cleaned_list.append(result)      
    
    # Fifth step - "zip" the years list and names list together and create a dictionary out of the result          
    for year, value, in zip(list2,cleaned_list):
        if year in combined_dict:
            combined_dict[year].append(value)
        else:
            combined_dict[year] = value

    # Sixth step - loop through the dictionary and separate the female names from the male names. Reassociate 
    # years to each set of name results to create two sex-specific dictionaries of name results by year searched.
    
    for year, names_list in combined_dict.items():
        first_half_names = [name.split()[0] for name in names_list]
        second_half_names = [name.split()[1] for name in names_list]
        new_dict[year] = second_half_names
        combined_dict[year] = first_half_names

    return combined_dict, new_dict

def get_names(driver, list):
    '''
    This function loops through user-given input of year(s). It 
     - finds the search box 
     - clears it
     - inputs a year into the search box
     - clicks submit
     - creates a table of the 20 most popular names for that year that were scraped from the website
     - increments the counter by one to search the next year (if applicable) and repeats, appending each new scrape to the previous.
     - returns a 2D list of names
    '''
    # loop through all subsequent years and collate results
    list_of_names = []
    for year in list:
            
        # Find the text box
        input_year = driver.find_element(By.ID,'yob') # locates input box
        input_year.clear()                             # clears box
        # Enter the year in question
        input_year.send_keys(str(year))           # fills in box with new date
                                       # adds in delay of one second
        # Clicks button to submit request
        input_year.submit()                            # clicks "go" button to submit data request
    
        # Scrape results here
        top_names = driver.find_elements(By.XPATH,"//html/body/table[2]/tbody/tr/td[2]/p/table") # Table path that includes each year's table title for clarity

        for name in top_names:
            list_of_names.append(name.text)
                     
    return list_of_names

